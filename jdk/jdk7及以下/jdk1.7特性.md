- **二进制字面量**
- **在数字字面量使用下划线**
- **switch可以使用string了**
- **实例创建的类型推断**
- **使用Varargs方法使用不可维护的形式参数时改进了编译器警告和错误**
- **try-with-resources 资源的自动管理**
- **捕捉多个异常类型和对重新抛出异常的高级类型检查**

> 以下代码中的变量名是随意取得，不可模仿

#### 一、二进制字面量

在JAVA SE 7，整数类型例如（byte，short，int，long）能够用二进制来表示了。通过在数字前面加入0b或者0B来标示一个二进制的字面量，看下面的例子

```java
//一个8位'byte'值：
byte aByte = (byte)0b00100001;

//一个16位'short'值:
short aShort = (short)0b1010000101000101;

//一些32位'int'值:
int anInt1 = 0b10100001010001011010000101000101;
int anInt2 = 0b101;
int anInt3 = 0B101; // B可以是大写也可以是小写.

//一个64位的'long'值. 注意"L"结尾:
long aLong = 0b1010000101000101101000010100010110100001010001011010000101000101L;
```

#### 二、在数字字面量使用下划线

在JAVA SE 7和以后的版本中，下划线字符（_）能够出现在数字字面量的数字之间的任何位置。这个功能可以用来对一个数字字面量根据位数分组，从而提高你代码的可读性。比如，如果你的代码包含一些数字有很多的位数，你能够用下划线字符把位数分为三组，类似于你用一个像逗号或者一个空格作为分隔符

```java
long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;
```

下划线只能出现在数字之间，下面的情形不能出现下划线：

- 数字的开头和结尾
- 在浮点数中与小数点相邻
- F或者L后缀之前
- 在预期数字串的位置

```java
float pi1 = 3_.1415F;      // 无效; 不能和小数点相邻
float pi2 = 3._1415F;      // 无效; 不能和小数点相邻
long socialSecurityNumber1 = 999_99_9999_L;         // 无效; 不能放在L后缀之前

int x1 = _52;              // 无效；这是个标识符，不是数字的字面量
int x2 = 5_2;              // OK
int x3 = 52_;              // 无效; 不能放在数字的结尾
int x4 = 5_______2;        // OK

int x5 = 0_x52;            // 无效; 不能放在 0x 中间 
int x6 = 0x_52;            // 无效; 不能放在数字的开头
int x7 = 0x5_2;            // OK
int x8 = 0x52_;            // 无效; 不能放在数字的结尾

int x9 = 0_52;             // OK 
int x10 = 05_2;            // OK
int x11 = 052_;            // Invalid; 不能放在数字的结尾
```

#### 三、switch可以使用string了

#### 四、实例创建的类型推断

> 由于编译器能够从上下文推断出参数类型，所以你可以用一组空类型参数（<>）替换泛型类构造函数的调用所需的类型参数。这对角括号通俗地称为菱形

#### 五、使用Varargs方法使用不可维护的形式参数时，改进了编译器警告和错误

#### 六、try-with-resources 资源的自动管理