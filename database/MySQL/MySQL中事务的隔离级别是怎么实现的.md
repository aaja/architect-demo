## 1 mysql中的事务

事务指的是MySQL中不可拆分的业务单元，具有ACID的属性。

## 2 ACID在数据库底层是怎么实现的

不同的特性底层的实现不一样，主要依赖两种日志和锁来实现

- 先说**持久性**：我们知道数据的操作会先在内存中完成，那么事务提交后如何保证一定能持久化到磁盘呢

- - redo log: 事务在提交前对数据的修改会先写到redo log 中，如果返回事务已提交成功，那么表示redo log已经记录完成。redo log 也有缓冲区，redo log的内存缓冲区大小和磁盘扇区的大小512字节一致，不会出现掉电易失的情况。另外redo log记录的是物理变化，体积很小，且redo log 写磁盘是顺序IO，极快
  - redo log 和binlog区别：一个是用于做持久化，另一个用作数据恢复和复制

- **原子性**，指的是被事务包裹的一组操作要么全部成功，要么全部失败。不会存在执行了一部分，另一部分不执行的情况
  - undo log: MySQL使用undo log实现操作回滚。事务开启后执行的命令都会有一条对应反向的逻辑日志计入undo日志文件中（譬如insert 就会有一条delete）。undo log的持久化会被记录在redo log中（利用redo log 速度快的特性）。一旦发生错误或者回滚的时候，利用undo就可以操作回去

**还有一致性和隔离性**

菜瓜：一致性和隔离性可以放在一起说，隔离级别的选择就是一致性和隔离性的权衡

- 实现多个事务之间的隔离。一种是锁，另一种是mvcc机制。

## mvcc是什么

我们把数据库的读操作分为两类，一是当前读，使用锁机制；一是快照读，使用mvcc

- 当前读 
  - 数据的修改操作（insert update delete）和查询时显示加锁 select(查询条件后加上 lock in share mode & for update)
  - 会锁住要读取的数据以保障数据的一致
- 快照读 使用的是mvcc机制，就是多版本并发控制。
  - 除当前读之外，普通的select查询为快照读，顾名思义，就是读取的是一个快照版本，以隔离多个事务之间的数据

## 原理

它的实现还是依赖undo log来做的

- 在RR RC两种级别下使用。其他两种不需要实现隔离
- 你肯定听说过mysql在RR级别下解决了幻读问题，就是依赖这个来做的
  - 简单来说就是，MySQL维护了一个记录活跃事务id的列表readview
  - undo log是怎么记录的呢。举个栗子🌰
    - innodb的表中存在三个额外的隐藏字段，分别是编辑该条记录的事务id，更改前的undo log的回滚指针，还有一个对我们这个分析不太重要
    - 如果有事务对该记录做了变更，事务id会更新，同时undo log里面会产生新记录，回滚指针字段指向最新的undo log链
    - 通过比较当前事务id和readview中其他事务的id大小来决定自己读取的数据是哪个版本的undo log记录
      - 如果当前事务id比readview中的都小，就说明该条记录没有被其他事务更改。直接读取
      - 如果当前事务id比readview中的都大，沿着undo log链能找到最小事务id指向的undo log，该数据为稳定数据
  - RR级别下利用该机制避免了幻读
  - RC级别下每次都会读取数据的最新记录

 

总结：

1. 事务的持久性和原子性由Redo log和Undo log实现
2. 隔离性和一致性的权衡由锁机制和MVCC实现

## mvcc的一点总结

MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

我们来具体看看是如何实现的。

**版本链**

我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：

**trx_id**

这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。

**roll_pointer**

每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

![](https://aaja.gitee.io/picture/architect-demo/20200804001.png)

比如现在有个事务id是60的执行的这条记录的修改语句

![](https://aaja.gitee.io/picture/architect-demo/20200804002.png)

此时在undo日志中就存在版本链

![](https://aaja.gitee.io/picture/architect-demo/20200804003.png)

**ReadView**

说了版本链我们再来看看ReadView。**已提交读和可重复读的区别就在于它们生成ReadView的策略不同。**

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

1、如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。

2、如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。

3、如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。

这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。

 

举个例子 ，在已提交读隔离级别下：

比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是

![](https://aaja.gitee.io/picture/architect-demo/20200804004.png)

那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。

这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。

那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务。

这时候版本链就是

![](https://aaja.gitee.io/picture/architect-demo/20200804005.png)

这时候之前那个select事务又执行了一次查询,要查询id为1的记录。

**这个时候关键的地方来了**

如果你是**已提交读隔离级别，这时候你会重新一个ReadView**，那你的活动事务列表中的值就变了，变成了[110]。

按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。

如果你是**可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]**。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！

**也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。**

这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。